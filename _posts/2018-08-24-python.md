##### 函数
默认参数的函数
可以简化函数的调用，并增加函数的扩展性

```
def power(x, n=2)
	s = 1
	while n > 0
		n = n - 1
		s = s * x
	return s

power(5)
power(5,3)
```

默认参数注意点，默认参数必须指向不变对象

```
def add_end(L=[])
	L.append('END')
	return L

add_end()
['END']

add_end()
['END','END']

add_end()
['END','END','END']

```

原因是Python函数在定义的时候，默认参数L的值就被计算出来了，即[],因为默认参数L也是一个变量，它指向对象[]，每次调用该函数，如果改变了L的内容，则下次调用时，默认参数的内容就变了，不再是函数定义时的[]了。

```
def add_end(L=None)
	if L is Node:
		L = []
	L.append('END')
	return L
```

#### 可变参数
传入的参数是不固定的

```
def calc(numbers):
	sum = 0
	for n in mubers:
		sum = sum + n * n
	return sum
calc([1,2,3])
```

利用可变参数，调用函数的方式可以简化成

```
calc(1,2,3)
calc(1,3,5,7)
```

可变函数的格式
```
def calc(*numbers):
	sum = 0
	for n in numbers:
		sum = sum + n * n
	return sum
```

定义可变参数和定义一个List或tuple参数相比，仅仅在参数前面加了一个*号。在函数内部，参数numbers接收到的是一个tuple,

list或tuple传入一个可变参数

```
nums = [1,2,3]
calc(*nums)
```
Python允许你在list或tuple前面加一个*号，把List货tuple的元素变成可变参数传进去。

##### 关键字参数
可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装成一个tuple。而关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在内部自动组装成dict

```
def person(name, age, **kw)
 	print('name':name,'age':age,'other',kw)
```

##### 命名关键字参数
用于限制关键字参数的名字，例如只接收city和job作为关键字参数

```
def person(name,age,*,city,job):
	print(name,age,city,job)
	
person('Jack',24,city='Beijin',job='Enginner')
```

如果函数中已经有了一个可变参数，后面跟着的命名关键字参数就不需要一个特殊分隔符*了：

```
def person(name,age,*arg,city,job)
	print(name,age,args,city,job)

person('xx','23','sss','xxx')
由于调用时缺少参数名city和job，Python解释器把这4个参数均视为位置参数，但person()函数仅接收两个位置参数。故而会报错。

```

带默认值的命名关键字参数
```
def person(name,age,*arg,city='beijin',job)
 	print(name,age,arg,city,job)
```

对于任意参数组合，通可以通过类似func(*args,**kw)的形式调用它。


#### 递归函数

我看到最容量理解解决汉诺塔的递归函数

```
def move(n,a,b,c)
	if n == 1:
		print(a,'-->',c)
	else:
		move(n-1,a,c,b)
		move(1,a,b,c)
		move(n-1,b,a,c)
```

#### 高级特性
##### 切片（Slice）
L[0:3]表示，从索引0开始取，直到索引3为止，但不包括索引3.
索引开始为0等价于L[:3]
倒数切片
L[-2:] 从倒数第二个开始取
tuple也可以用切片操作

##### 迭代
python 中迭代是通过for ... in 来完成
只要是可以迭代的对象都可以用for ... in

```
d = {'a':1,'b':2,'c':3}
for key in d:
	print(key)

```
dict迭代的是Key,如果要迭代value可以用for value in d.value,如果要迭代key和value，可以用for k, v in d.items()

判断一个对象是否可以迭代，方法是通过collections模块的iterable类型判断

对list实现类似java那样的下标循环，python内置的enumerate函数可以吧list变成索引-元素对
for i,value in enumerate(['a','b','c'])
	print(i,value)
	
##### 装饰器

函数对象有一个__name__属性，可以拿到函数的名字

在代码运行期间动态增加功能的方式，称之为装饰器("Decorator")

本质上，decorator就是一个返回函数的高价函数，所以，我们要定义一个能打印日志的decorator

```
def log(func):
	def wrapper(*args,**kw):
		print('call %():' % func.__name__)
		return func(*args,**kw)
	return wrapper

@log
def now():
	print('2015-3-25')

```
把@log放到now()函数定义处，相当于执行了语句
now = log(now)

由于log()是一个decorator,返回一个函数，原来的now()函数仍然存在，只是现在同名的now变量指向了新的函数，于是调用now()函数将执行新的函数，即在wrapper中返回的wrapper函数()

如果decorator本身需要传入参数，那就需要编写一个返回decorator的高价函数。

```
def log(text)
	def decorator(func):
		def wrapper(*args,**kw)
			print('%s %s():' % (text,func.__name__))
			return func(*arg,**kw)
		return wrapper
	return decorator

@log('execute')
def now():
	print('2015-3-25')
	
```
三层嵌套的效果是
now = log('execute')(now)

可以看出返回值最终是wrapper函数。所以__name__已经从原来的'now'变成了'wrapper',可以通过functools.wraps模块解决这个问题

```
import functools

def log(func):
	@functools.wraps(func)
	def wrapper(*args, **kw):
		print('call %():' % func.__name__)
		return func(*arg,**kw)
	return wrapper
	
	import functools

def log(text):
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kw):
            print('%s %s():' % (text, func.__name__))
            return func(*args, **kw)
        return wrapper
    return decorator
```

python直接从语法层次支持decorator,OOP的装饰模式需要通过继承和组合来实现


#### 偏函数
通过设定默认值，可以降低函数调用的难度。而偏函数可以做到这点，通过设置默认值指定成一个新的函数

```
import functools
int2 = functools.partial(int, base = 2)
int2('100000')

max2 = functools.partial(max, 10)
max2(5,6,7)
相当于
max2(10,5,6,7)
```

自定义偏函数实现

```
def my_partial(func, *args, **kw):
	@functools.wraps(func)
	def wrapper(*arg):
		return func(*args+arg, **kw)
	return wrapper
```

#### 第三方模块
通过Anaconada3管理python,安装brew cask install anaconad

设置环境变量
export PATH=/usr/local/anaconda3/bin:"$PATH"

Anaconda3也会给你默认安装一个python3.6的稳定版本，设置python3.7需要进行如下操作

```
conda create -n py37 python=3.7
source active py37
python -V
```

**注意前面conda自带的一些第三方依赖没有为新安装的3.7设置依赖，只需要安装一下即可**
```
conda install numpy
```

#### 面向对象编程
访问限制
如果要让内部属性不被外部访问，可以把属性名称前加上两个下划线__，表示为私有

class Student(object):

	def __init__(self,name,score):
		self.__name = name
		self.__score = scor
		
创建一个class的实例后，我们可以给实例绑定任何属性和方法，这是动态语言的灵活性
通过__slots__变量，可以限制改class实例能添加的属性

```
clsss Student(object):
	__slots__ = ('name','age')
```

\__slots__关键字只对当前类实例起作用，对继承的子类是不起作用的

#### 定制类

```
__str__



class Student(object):
	def __str__(self):
		return 'xxxxxx'

__iter__
__next__	
class Fib(object):
	"""docstring for Fib"""
	def __init__(self):
		self.a, self.b = 0,1

	def __iter__(self):
		return self

	def __next__(self):
		self.a,self.b = self.b,self.a + self.b
		if self.a > 100000:
			raise StopIteration()
		return self.a
		
__getitem__
可以实现下标访问
		
		
```

当调用不存在的属性的时候，会调用下面方法
```
def _getattr__(self, attr):
```

设置属性时候调用
```
def __setattr__(self, attr):
	
```

下面代码通过重载__getattr__和__setattr__，可以吧self[key]和self.key两种方式关联起来

```
class Model(dict):
	def __getattr__(self,key):
		try return self[key]
	except KeyError:
		raise AttributeError('xxxxx')
		
	def _setattr_(self, key, value):
		self[key] = value
```


#### 枚举类
用法示例
```
from enum import Enum, unique

@unique
class Weekday(Enum):
	Sun = 0
	Mon = 1
	Tue = 2
	Wed = 3
	Thu = 4
	Fri = 5
	Sat = 6
```
@unique装饰器可以帮助我们检查没有重复值。

#### 使用元类
##### type()
动态语言和静态语言最大的不同，就是函数和类的定义，不是编译时定义的，而是运行时动态创建的。
type()函数可以查看一个类型或变量的类型
class的定义是运行时期动态创建的，创建class的方法就是使用type()函数
type()函数既可以返回一个对象的类型，又可以创建出新的类型

type函数创建类
type('类名',(父类,),dict)

要创建一个class对象，type()函数依次传入3个参数:

1. class的名称
2. 继承的父类集合
3. class的方法名称与函数绑定，这里我们把函数fn绑定到方法名hello上

metaclass
除了使用type()动态创建类外，要控制类的创建行为，还可以使用mataclass.
它的解释是：
当我们定义了类以后，就可以根据这个类创建出实例，所以：先定义类，然后创建实例。  
但是如果我们想创建出类呢？那就必须根据metaclass创建出来，所以：先定义metaclass,然后创建类。  
链接起来就是：先定义metaclass,就可以创建类，最后创建实例

```
class ListMetaclass(type):
	def __new__(cls,name,base,attrs):
		attrs['add'] = lambda self, value:self.append(value)
		return type.__new__(cls,name,bases,attrs)
class MyList(list,metaclass=ListMetaclass):
	pass
```
\__new()\__方法接收的参数依次是:

* 1.当前准备创建的类对象；
* 2.类的名字；
* 3.类继承的父类集合；
* 4.类的方法集合

动态修改有什么意义，在MyList定义中写上add()方法不是很简单吗？正常情况下，确实应该直接写，通过metaclass修改纯属变态。  
但是，总会遇到需要metaclass修改类定义的，ORM是一个典型的例子
ORM-Object Relational Mapping,即对象-关系映射，就是把关系数据库的一行映射为一个对象，也就是一个雷对应一个表。  
编写一个ORM框架，所有的类都只能动态定义，因为只有使用者才能根据表的结果定义出对应的类来。










#### 文件读写
读写文件是最常见的IO操作。Python内置类读写文件的函数，用法和C是兼容的
在磁盘上读写文件的功能都是由操作系统提供的，现在操作系统不允许普通的程序直接操作磁盘，读写文件就是请求操作系统打开一个文件对象(通常称为文件描述)，然后，通过操作系统提供的接口从这个文件描述中读取数据，或写数据

##### 读文件

```
f = open('Users/jsonsnow/text.txt','r')
```

如果文件读取成功，接下来，调用read()方法可以一次读取文件的全部内容，Python把内容读取到内存，用一个str对象表示  
最后一步是调用close()方法关闭文件。文件使用完毕后必须关闭，因为文件对象会占用操作系统的资源，并且操作系统同一时间打开的文件数量是有限的。

```
f.close()
```

由于文件读写都有可能产生IOError,一旦出错，后面的f.close()就不会调用

```
try:
	f = open('path/to/file','r')
	print(f.read())
finally:
	if f:
		f.close()
		
```

python引入了with语句来自动帮我们调用close()方法：

```
with open('/path/to/file','r') as f:
	print(f.read())
```
read()会一次性读取文件的全部内容，如果文件有10g，内存就爆了，可以反复调用read(size)方法  
readline()可以每次读取一行内容，调用readlines()一次读取所有内容，并按行返回list。因此更具需求决定怎样调用  
如果文件很小，read()一次性读取最方便；如果不确定文件大小，反复调用read(size)比较保险，如果是配置文件readlines()最方便。

```
for line in f.readlines():
	print(line.strip())
```

#### file-like Object
像open()返回的这种有read()方法的对象，在python中统称为file-like Object.除了file外，还可以是内存的字节流，网络流，自定义流等。file-like Object不要求指定类继承，只需要写个read()方法就行。

StringIO就是在内存中创建的file-like Object,常用作临时缓冲。

#### 二进制文件
前面默认都是读取文本文件，并且是UTF-8编码的文本文件，要读取二进制文件，比如图片、视频等等，用'rb'方式打开。

```
f = open('/Users/michal/test.jpg','rb')
f.read()
```	

#### 字符编码
要读取非UTF-8编码的文本文件，需要给open()函数传入encoding参数，例如，读取GBK编码的文件。

```
f = open('Users/snow/michal/gbk.txt','r',encoing='gbk')
f.read()
```

遇到游戏编码不规范的文件，你可能会遇到UnicodeDecodeError,因为在文本文件中可能夹杂了一些非法编码的字符，遇到这种情况，open()还能接收一个errors参数，表示如果遇到编码错误后如何处理。最简单的方式是直接忽略。

```
f = open('/Users/snow/gbk.txt','r',encoding = 'gbk',error='ignore')
```

#### 写文件
写文件和读文件是一样的，唯一区别是调用open()函数时，传入标识符'w'或者'wb'表示文本文件或写二进制文件:

```
f = open('/Users/snow/test.txt','w')
f.write('Hello ,world!')
f.cloe()
```

你可以反复调用write()来写入文件，但是务必调用f.close()来关闭文件。当我们写文件时，操作系统往往不会立刻写入磁盘，而是放在内存缓存起来，空闲的时候再慢慢写入。只有调用close()方法，操作系统才保证把没写入内存的数据全部写入磁盘。

```
with open('/Users/snow/txt.txt','w') as f:
	f.write('Hello ,world!')
```
上面方式会直接覆盖已存在的文件

要写入特定编码的文本文件，请给open()函数传入encoding参数，将字符串自动转换成指定编码。

```
with open('/Users/snow/txt.txt','a') as f:
	f.write('Hello ,world!')
```

#### StringIO和BytesIO
StringIO在内存中读写str

```
from io import StringIO
f = StringIO()
f.write('hello')
f.write(' ')
f.wirte('world!')
print(f.getvalue())
```

BytesIO实现了在内存中读取bytes，

```
from io import BytesIO
f = BytesIO()
f.write('中文'.encode('utf-8'))
print(f.getvalue())

f = BytesIO(b'\xe4\xb8\xad\xe6\x96\x87')
f.read()

```

#### 序列化
在程序运行的过程中，所有变量都是在内存中 
把变量从内存中变成可存储或传输的过程称之为序列化，在python中叫picklink,在其他语言中称之为serialization,marshalling,flatening等等。  
徐序列化之后，就可以吧序列化后的内容写入磁盘，或者通过网络传输到别的机器上。  
反过来，把变量内容从序列化的对象重新独到内存里称之为反序列化，unpicking.
不过pickle是python才能识别，下面介绍json

##### json
```
import json
d = dict(name='bob',age=20,score=88)
json_str = json.dumps(d)
json.loads(json_str)

json_str = ''
```

##### JSON进价

```
import json
class Student(object):
	def __init__(self, name, age, score):
		self.name = name
		self.age = age
		self.score = score
		
def student2dict(std):
	return {
		'name':std.name,
		'age':std.age,
		'score':std.score
	}

		
```
对于自定义对象，需要提供一个序列化的函数

```
json.dumps(s,default=student2dict)
```


##### 注意事项

* 1.不要有压力(大部分都是我在和自己较真)
* 2.
* 2.感谢长久以来的不嫌弃

















